use num_bigint::BigInt;
use num_traits::{One, Zero};

fn egcd(a: BigInt, b: BigInt) -> (BigInt, BigInt, BigInt) {
    if a.is_zero() {
        return (b, BigInt::zero(), BigInt::one());
    } else {
        let (g, x, y) = egcd(b.clone() % a.clone(), a.clone());
        return (g, y - (b / a) * x.clone(), x);
    }
}

fn invmod(a: BigInt, m: BigInt) -> BigInt {
    let (g, x, _) = egcd(a.clone(), m.clone());
    if g != BigInt::one() {
        panic!("No modular inverse exists!");
    } else {
        (x % m.clone() + m.clone()) % m
    }
}

fn crt(c: Vec<BigInt>, n: Vec<BigInt>) -> BigInt {
    let mut sum = BigInt::zero();
    let prod: BigInt = n.iter().product();

    for (c_i, n_i) in c.iter().zip(n.iter()) {
        let p = &prod / n_i;
        sum += c_i * &p * invmod(p, n_i.clone());
    }

    sum % prod
}

fn integer_cube_root(n: BigInt) -> BigInt {
    let mut low = BigInt::zero();
    let mut high = n.clone();

    while &high - &low > BigInt::one() {
        let mid = (&low + &high) >> 1;
        let mid_cubed = &mid * &mid * &mid;

        if mid_cubed > n {
            high = mid;
        } else {
            low = mid;
        }
    }
    low
}

fn rsa_broadcast_attack(c: Vec<BigInt>, n: Vec<BigInt>) -> BigInt {
    let combined = crt(c, n);
    integer_cube_root(combined)
}

fn main() {
    // Example usage:
    // Three public keys (n_0, n_1, n_2) and corresponding ciphertexts (c_0, c_1, c_2)
    let n_0 = BigInt::parse_bytes(b"179681515177599890119423806867251574469417389737064238418406743739407326240098591695893205420245549258844128345295054773037765768189964309288649476890967057594430228478581047595833996556185917598585760911950364623333826536709629038074204105969138118508745631235580444352938531230531573970282234487267761229819", 10).unwrap();
    let n_1 = BigInt::parse_bytes(b"201051347770029255654821840825335513220424042755656160053971800022028568314673858978498722553173470576239929118856235583524545993283298565606166879602006188264963057448963334905675730858723432376279548278507199269218675841843365038476186986764488143401631393468986046622719611687122122795940236143589478044689", 10).unwrap();
    let n_2 = BigInt::parse_bytes(b"129392588467766597564127529247547810298454928749969276394602326299994274760313617898136706089953599885176037419854672979252922472465644573492234546503384073384751968837413729107970943232780824689627633083441051536175142777893670059022174457127369125042420618230029080116129084138401038434562798112202199511551", 10).unwrap();

    let c_0 = BigInt::parse_bytes(b"220964518674103817763065611348834180174100697878928310717318391436761356001205380042823296504735094243439462197515122564658399679428894607645420405815647489455724155288777034967611600432188544951086176540912659005449429141380778747605899740859007398031993972594384671417476540237698176314724707127618246144", 10).unwrap();
    let c_1 = BigInt::parse_bytes(b"220964518674103817763065611348834180174100697878928310717318391436761356001205380042823296504735094243439462197515122564658399679428894607645420405815647489455724155288777034967611600432188544951086176540912659005449429141380778747605899740859007398031993972594384671417476540237698176314724707127618246144", 10).unwrap();
    let c_2 = BigInt::parse_bytes(b"220964518674103817763065611348834180174100697878928310717318391436761356001205380042823296504735094243439462197515122564658399679428894607645420405815647489455724155288777034967611600432188544951086176540912659005449429141380778747605899740859007398031993972594384671417476540237698176314724707127618246144", 10).unwrap();

    let c = vec![c_0, c_1, c_2];
    let n = vec![n_0, n_1, n_2];

    let message = rsa_broadcast_attack(c, n);

    println!("Recovered message: {}", message);
}